
---

## 1ï¸âƒ£ What is a CyclicBarrier in Java?

`CyclicBarrier` is a **synchronization aid** that allows a **fixed number of threads to wait for each other** at a common barrier point.

ðŸ‘‰ All threads call `await()`
ðŸ‘‰ When the **last thread arrives**, **all waiting threads are released together**
ðŸ‘‰ The barrier is then **reset automatically** and **can be reused** (thatâ€™s why itâ€™s called *cyclic*)

### Real-life analogy

> A group of friends wants to start a trek **together**.
> Everyone waits at the base camp.
> When the last person arrives â†’ **everyone starts the trek together**.

---

### Example: CyclicBarrier

```java
import java.util.concurrent.CyclicBarrier;

class Task implements Runnable {
    private CyclicBarrier barrier;

    Task(CyclicBarrier barrier) {
        this.barrier = barrier;
    }

    public void run() {
        try {
            System.out.println(Thread.currentThread().getName() + " reached barrier");
            barrier.await(); // wait for others
            System.out.println(Thread.currentThread().getName() + " started after barrier");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

public class CyclicBarrierDemo {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(3);

        new Thread(new Task(barrier)).start();
        new Thread(new Task(barrier)).start();
        new Thread(new Task(barrier)).start();
    }
}
```

ðŸ”¹ All 3 threads wait
ðŸ”¹ Once all reach the barrier â†’ all proceed together
ðŸ”¹ Barrier can be reused again

---

## 2ï¸âƒ£ What is CountDownLatch?

`CountDownLatch` is a **one-time latch** that allows **one or more threads to wait until a set of operations completes**.

ðŸ‘‰ Initialized with a count
ðŸ‘‰ Other threads call `countDown()`
ðŸ‘‰ Waiting thread(s) call `await()`
ðŸ‘‰ Once count reaches **0**, latch opens **forever**

### Real-life analogy

> Exam starts **only after** all students enter the hall.
> Once exam starts, you **canâ€™t reset** the process.

---

### Example: CountDownLatch

```java
import java.util.concurrent.CountDownLatch;

class Worker implements Runnable {
    private CountDownLatch latch;

    Worker(CountDownLatch latch) {
        this.latch = latch;
    }

    public void run() {
        System.out.println(Thread.currentThread().getName() + " finished work");
        latch.countDown();
    }
}

public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3);

        new Thread(new Worker(latch)).start();
        new Thread(new Worker(latch)).start();
        new Thread(new Worker(latch)).start();

        latch.await(); // main thread waits
        System.out.println("All workers finished. Main thread continues.");
    }
}
```

ðŸ”¹ Main thread waits
ðŸ”¹ Workers decrement count
ðŸ”¹ When count = 0 â†’ main thread resumes
ðŸ”¹ Cannot reuse latch

---

## 3ï¸âƒ£ CyclicBarrier vs CountDownLatch (ðŸ”¥ Interview Favorite)

| Feature             | CyclicBarrier               | CountDownLatch                  |
| ------------------- | --------------------------- | ------------------------------- |
| Reusability         | âœ… Yes (cyclic)              | âŒ No (one-time)                 |
| Threads wait for    | **Each other**              | **Other threads to finish**     |
| Reset automatically | âœ… Yes                       | âŒ No                            |
| Who calls await()   | All threads                 | Usually main thread             |
| Barrier action      | âœ… Optional                  | âŒ No                            |
| Typical use case    | Parallel computation phases | Startup / shutdown coordination |

---

## 4ï¸âƒ£ Barrier Action (Important Point)

CyclicBarrier allows a **barrier action** â†’ a task that runs **once** when the last thread arrives.

```java
CyclicBarrier barrier = new CyclicBarrier(3, () -> {
    System.out.println("All threads reached barrier. Barrier action executed.");
});
```

âš ï¸ CountDownLatch has **no such feature**

---

## 5ï¸âƒ£ When to Use What?

### Use **CyclicBarrier** when:

âœ” Threads must wait for each other
âœ” You have **phases** (e.g., map â†’ process â†’ reduce)
âœ” You want reuse

### Use **CountDownLatch** when:

âœ” One thread waits for many
âœ” One-time event
âœ” Startup or shutdown coordination

---

## 6ï¸âƒ£ One-Line Interview Answer

> **CountDownLatch** is a one-time synchronization aid where threads wait until a count reaches zero, while **CyclicBarrier** allows a fixed number of threads to wait for each other and can be reused for multiple cycles.

---
