
---

## Example: Reusing CyclicBarrier for Multiple Cycles

### Scenario

We have **3 worker threads**.
Each worker does **2 phases of work**:

1. Phase 1 â†’ wait at barrier
2. Phase 2 â†’ wait at barrier again

The **same CyclicBarrier** is reused for both phases.

---

### Code Example

```java
import java.util.concurrent.CyclicBarrier;

class Worker implements Runnable {
    private CyclicBarrier barrier;

    Worker(CyclicBarrier barrier) {
        this.barrier = barrier;
    }

    @Override
    public void run() {
        try {
            // -------- Phase 1 --------
            System.out.println(Thread.currentThread().getName() + " completed Phase 1");
            barrier.await(); // wait for others

            // -------- Phase 2 --------
            System.out.println(Thread.currentThread().getName() + " completed Phase 2");
            barrier.await(); // reuse SAME barrier

            System.out.println(Thread.currentThread().getName() + " finished all phases");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

public class CyclicBarrierReuseDemo {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(3, () -> {
            System.out.println("---- All threads reached barrier. Moving to next phase ----");
        });

        new Thread(new Worker(barrier), "Thread-1").start();
        new Thread(new Worker(barrier), "Thread-2").start();
        new Thread(new Worker(barrier), "Thread-3").start();
    }
}
```

---

## Sample Output (Order may vary)

```
Thread-1 completed Phase 1
Thread-2 completed Phase 1
Thread-3 completed Phase 1
---- All threads reached barrier. Moving to next phase ----

Thread-2 completed Phase 2
Thread-1 completed Phase 2
Thread-3 completed Phase 2
---- All threads reached barrier. Moving to next phase ----

Thread-1 finished all phases
Thread-2 finished all phases
Thread-3 finished all phases
```

---

## ðŸ”‘ Whatâ€™s Happening Internally?

### Phase 1

* All threads call `await()`
* Count reaches 0
* Barrier action runs
* Barrier **resets automatically**

### Phase 2 (Reuse!)

* Same threads again call `await()`
* Same barrier logic applies
* No new barrier object needed

ðŸ‘‰ This automatic reset is why itâ€™s called **CyclicBarrier**

---

## âŒ Why CountDownLatch Canâ€™t Do This

```java
CountDownLatch latch = new CountDownLatch(3);
```

Once count reaches `0`:

* Latch is **dead**
* You must create a **new latch**
* No automatic reuse

---

## Interview Tip (One-Liner)

> CyclicBarrier can be reused because once all threads reach the barrier, it automatically resets, allowing the same threads to synchronize again in the next phase.

---
