
---

# ðŸ“˜ **Notes: Inheritance**
---


## âœ… **Inheritance**
- We can look at Inheritance as a form of code reuse.
- It's a way to organize classes into a parent-child hierarchy, which lets the child inherit (reuse), fields and methods from its parent.

```java
public class Animal
{
    protected String type;
    private String size;
    private double weight;

    public Animal()
    {
        System.out.println("Animal constructor called");
    }

    public Animal(String type, String size, double weight)
    {
        this.type = type;
        this.size = size;
        this.weight = weight;
    }

    @Override
    public String toString()
    {
        return "Animal{" +
                "type='" + type + '\'' +
                ", size='" + size + '\'' +
                ", weight=" + weight +
                '}';
    }

    public void move(String speed)
    {
        System.out.println(type + " moves " + speed);
    }

    public void makeNoise()
    {
        System.out.println(type + " makes some kind of noise");
    }
}

public class Dog extends Animal
{
    private String earShape;
    private String tailShape;

    public Dog()
    {
        super("Mutt", "Big", 50);
    }

    public Dog(String type, double weight)
    {
        this(type, weight, "Perky", "Curled");
    }

    public Dog(String type, double weight, String earShape, String tailShape)
    {
        super(type, weight < 15 ? "Small" : (weight < 35) ? "Medium" : "Big", weight);
        this.earShape = earShape;
        this.tailShape = tailShape;
    }

    @Override
    public String toString()
    {
        return "Dog{" +
                "earShape='" + earShape + '\'' +
                ", tailShape='" + tailShape + '\'' +
                '}' + " " + super.toString();
    }

    @Override
    public void move(String speed)
    {
        if(speed == "slow")
        {
            walk();
            wagTail();
        }
        else
        {
            run();
            bark();
        }

        System.out.println();
    }

    @Override
    public void makeNoise()
    {
        if(type == "Wolf")
        {
            System.out.println("Ow Wooooo!");
        }

        bark();
        System.out.println();
    }

    private void bark()
    {
        System.out.print("WooF!");
    }

    private void run()
    {
        System.out.print("Dog Running");
        System.out.println();
    }

    private void walk()
    {
        System.out.print("Dog Walking ");
    }

    private void wagTail()
    {
        System.out.print("Tail Wagging ");
    }
}

public class Fish extends Animal
{
    private int gills;
    private int fins;

    public Fish(String type, double weight, int gills, int fins)
    {
        super(type, "small", weight);
        this.gills = gills;
        this.fins = fins;
    }

    private void moveMuscles()
    {
        System.out.print("muscles moving ");
    }

    private void moveBackFin()
    {
        System.out.print("backfin moving ");
    }

    @Override
    public void move(String speed)
    {
        super.move(speed);
        moveMuscles();
        if (speed == "fast")
        {
            moveBackFin();
        }
        System.out.println();
    }

    @Override
    public String toString()
    {
        return "Fish{" +
                "gills=" + gills +
                ", fins=" + fins +
                "} " + super.toString();
    }
}


public class Main
{
    public static void main(String[] args)
    {
        Animal animal = new Animal("Generic Animal", "Huge", 400);
        doAnimalStuff(animal, "slow");

        Dog dog = new Dog();
        doAnimalStuff(dog, "fast");

        Dog yorkie = new Dog("Yorkie", 15);
        doAnimalStuff(yorkie, "fast");

        Dog retriever = new Dog("Labrador Retriever", 65, "Floppy", "Swimmer");
        doAnimalStuff(retriever, "slow");

        Dog wolf = new Dog("Wolf", 40);
        doAnimalStuff(wolf, "slow");

        Fish goldie = new Fish("Goldfish", 0.25, 2, 3);
        doAnimalStuff(goldie, "fast");

    }

    public static void doAnimalStuff(Animal animal, String speed)
    {
        System.out.println(animal);
        animal.makeNoise();
        animal.move(speed);
        System.out.println("- - - -");
    }
} 

```

```text
Animal{type='Generic Animal', size='Huge', weight=400.0}
Generic Animal makes some kind of noise
Generic Animal moves slow
- - - -
Dog{earShape='null', tailShape='null'} Animal{type='Mutt', size='Big', weight=50.0}
WooF!
Dog Running
WooF!
- - - -
Dog{earShape='Perky', tailShape='Curled'} Animal{type='Yorkie', size='Medium', weight=15.0}
WooF!
Dog Running
WooF!
- - - -
Dog{earShape='Floppy', tailShape='Swimmer'} Animal{type='Labrador Retriever', size='Big', weight=65.0}
WooF!
Dog Walking Tail Wagging 
- - - -
Dog{earShape='Perky', tailShape='Curled'} Animal{type='Wolf', size='Big', weight=40.0}
Ow Wooooo!
WooF!
Dog Walking Tail Wagging 
- - - -
Fish{gills=2, fins=3} Animal{type='Goldfish', size='small', weight=0.25}
Goldfish makes some kind of noise
Goldfish moves fast
muscles moving backfin moving 
- - - -
```
---

# â­ **1. CLASS STRUCTURE (Inheritance Hierarchy)**

You have **3 classes** that extend each other:

```
Animal  â†  Dog
Animal  â†  Fish
```

So:

* **Animal** is the **superclass / base class**
* **Dog** and **Fish** are **subclasses** of Animal
* Dog & Fish inherit fields and methods from Animal

This demonstrates **inheritance (IS-A relationship)**.

---

# â­ **2. CLASS: Animal**

```java
protected String type;
private String size;
private double weight;
```

Key points:

* `type` â†’ **protected** â†’ accessible in subclasses (Dog, Fish)
* `size` and `weight` â†’ **private** â†’ cannot be accessed directly in subclasses (only via constructor)

### **Constructors**

Animal has two constructors:

#### **Default constructor**

```java
public Animal() {
    System.out.println("Animal constructor called");
}
```

#### **Parameterized constructor**

```java
public Animal(String type, String size, double weight) {
    this.type = type;
    this.size = size;
    this.weight = weight;
}
```

**Constructor Overloading** is demonstrated.

---

# â­ **3. METHODS IN ANIMAL**

### **toString()**

Overrides Object.toString()
Returns animal data.

### **move(String speed)**

Simply prints how the animal moves.

### **makeNoise()**

Generic noise.

---

# â­ **4. CLASS: Dog extends Animal**

Dog has **additional fields**:

```java
private String earShape;
private String tailShape;
```

---

# â­ **5. Dog Constructors (Constructor Chaining + super)**

### **Default Dog constructor**

```java
public Dog() {
    super("Mutt", "Big", 50);
}
```

Calls Animal constructor â†’ **constructor chaining via super()**

---

### **Two-parameter constructor**

```java
public Dog(String type, double weight) {
    this(type, weight, "Perky", "Curled");
}
```

Uses **this()** â†’ calls another constructor in the same class.

---

### **Main Dog constructor**

```java
super(type, weight < 15 ? "Small" : (weight < 35) ? "Medium" : "Big", weight);
```

Uses a **ternary conditional operator** to compute `size` based on weight.

Example:

* weight < 15 â†’ Small
* weight < 35 â†’ Medium
* else â†’ Big

---

# â­ **6. Dog Overridden Methods (POLYMORPHISM)**

### **toString()**

Adds Dog fields and Animal fields.

---

### **move(String speed)**

```java
if (speed == "slow")  // WRONG comparison
```

âš  **Problem**: Using `==` to compare strings checks **memory address**, not value.
Should use `.equals()`.

Example:

```java
if (speed.equals("slow"))
```

But let's continue with the logic:

* slow â†’ walk + wag tail
* fast â†’ run + bark

Dog behavior changes depending on speed.

This is **method overriding** + **dynamic behavior**.

---

### **makeNoise()**

```java
if (type == "Wolf")
```

âš  Again string comparison error (should use `.equals()`)

Logic:

* If dog type is "Wolf" â†’ howl
* Otherwise â†’ bark

Uses helper methods:

* `bark()`
* `walk()`
* `run()`
* `wagTail()`

All **private** methods â†’ only for Dog class internal behavior.

---

# â­ **7. CLASS: Fish extends Animal**

Fish adds fields:

```java
private int gills;
private int fins;
```

### **Constructor**

```java
super(type, "small", weight);
```

Fish size is always "small".
Also demonstrates **super() constructor chaining**.

---

### **Fish private movement helpers**

```
moveMuscles()
moveBackFin()
```

These simulate swimming.

---

### **move(String speed)** (Overridden)

```java
super.move(speed);
moveMuscles();
if (speed == "fast") {
    moveBackFin();
}
```

Again:

* Uses **super.move()** to reuse Animal behavior
* Adds Fish-specific movement
* Adds fast-speed behavior

Method overriding + using parent method.

---

### **toString()**

Adds Fish fields + Animal fields.

---

# â­ **8. CLASS: Main (Polymorphism in Action)**

```java
Animal animal = new Animal("Generic Animal", "Huge", 400);
doAnimalStuff(animal, "slow");
```

Next:

```java
Dog dog = new Dog();
doAnimalStuff(dog, "fast");
```

Even though `doAnimalStuff()` accepts Animal:

```java
public static void doAnimalStuff(Animal animal, String speed)
```

You can pass:

* Animal
* Dog
* Fish

Because **Dog and Fish ARE-A Animal**
This is **upcasting**.

---

# â­ **9. POLYMORPHISM (Runtime method dispatch)**

Inside:

```java
animal.makeNoise();
animal.move(speed);
```

This is the most important concept:

Even though the reference is of type **Animal**,
Java will call the **overridden version** from the actual object (Dog/Fish).

This is **runtime polymorphism (dynamic binding).**

Examples:

* Dog overrides `move()` â†’ Dogâ€™s move() runs
* Fish overrides `move()` â†’ Fishâ€™s move() runs
* Animal doesn't override â†’ its own version runs

---

# â­ **10. doAnimalStuff() Method**

```java
System.out.println(animal);
animal.makeNoise();
animal.move(speed);
System.out.println("- - - -");
```

This shows:

* **toString() polymorphism**
* **makeNoise() polymorphism**
* **move() polymorphism**
* Polymorphic behavior for all subclasses

---

