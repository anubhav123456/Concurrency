
---

# Thread Creation in Java

Java provides multiple ways to create threads. The four most commonly used approaches are:

1. Extending the `Thread` class
2. Implementing the `Runnable` interface
3. Using Anonymous Inner Class
4. Using Lambda Expression

---

## 1. Creating a Thread by Extending the `Thread` Class

### Code

```java
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + " is running " + i);
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                System.out.println("Thread interrupted.");
            }
        }
    }
}
```

### Usage

```java
MyThread thread1 = new MyThread();
thread1.start();
```

### Pros

✅ Simple and easy to understand
✅ Direct access to `Thread` methods (`getName()`, `getPriority()` etc.)
✅ Good for learning multithreading basics

### Cons

❌ **Java does not support multiple inheritance**, so you cannot extend any other class
❌ Tight coupling between task logic and thread
❌ Not recommended for large-scale or enterprise applications

---

## 2. Creating a Thread by Implementing `Runnable` Interface

### Code

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + " is running " + i);
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                System.out.println("Thread interrupted.");
            }
        }
    }
}
```

### Usage

```java
MyRunnable runnable = new MyRunnable();
Thread thread2 = new Thread(runnable);
thread2.start();
```

### Pros

✅ Supports **multiple inheritance** (can extend another class)
✅ Better **separation of concern** (task ≠ thread)
✅ Recommended approach in real-world applications
✅ Compatible with Executor Framework

### Cons

❌ Slightly more verbose than extending `Thread`
❌ Cannot directly access Thread methods without `Thread.currentThread()`

---

## 3. Creating a Thread Using Anonymous Inner Class

### Code

```java
Thread thread3 = new Thread(new Runnable() {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + " is running " + i);
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                System.out.println("Thread interrupted.");
            }
        }
    }
});
```

### Usage

```java
thread3.start();
```

### Pros

✅ No need to create a separate class
✅ Useful for **one-time tasks**
✅ Reduces boilerplate code

### Cons

❌ Readability decreases for complex logic
❌ Harder to debug
❌ Cannot reuse the logic

---

## 4. Creating a Thread Using Lambda Expression (Java 8+)

### Code

```java
Thread thread4 = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println(Thread.currentThread().getName() + " is running " + i);
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            System.out.println("Thread interrupted.");
        }
    }
});
```

### Usage

```java
thread4.start();
```

### Pros

✅ **Shortest and cleanest syntax**
✅ Best readability
✅ Ideal for small tasks
✅ Works perfectly with functional programming

### Cons

❌ Not suitable for very complex logic
❌ Can reduce clarity if overused

---

## Complete Working Program (All 4 Methods Together)

```java
public class Main {
    public static void main(String[] args) {

        MyThread thread1 = new MyThread();

        MyRunnable runnable = new MyRunnable();
        Thread thread2 = new Thread(runnable);

        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 5; i++) {
                    System.out.println(Thread.currentThread().getName() + " is running " + i);
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        System.out.println("Thread interrupted.");
                    }
                }
            }
        });

        Thread thread4 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + " is running " + i);
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    System.out.println("Thread interrupted.");
                }
            }
        });

        thread1.start();
        thread2.start();
        thread3.start();
        thread4.start();
    }
}
```

---

## Output (Sample)

```
Thread-3 is running 0
Thread-0 is running 0
Thread-1 is running 0
Thread-2 is running 0
Thread-0 is running 1
Thread-2 is running 1
Thread-3 is running 1
Thread-1 is running 1
Thread-0 is running 2
Thread-1 is running 2
Thread-2 is running 2
Thread-3 is running 2
Thread-3 is running 3
Thread-0 is running 3
Thread-2 is running 3
Thread-1 is running 3
Thread-1 is running 4
Thread-3 is running 4
Thread-2 is running 4
Thread-0 is running 4
```

### Why Output Order Changes?

* Thread scheduling is **handled by JVM + OS**
* No guaranteed execution order
* `Thread.sleep()` pauses only the **current thread**

---

## Quick Interview Comparison Table

| Method              | Recommended? | Use Case            |
| ------------------- | ------------ | ------------------- |
| Extends Thread      | ❌ No         | Learning basics     |
| Implements Runnable | ✅ Yes        | Real applications   |
| Anonymous Class     | ⚠️ Sometimes | One-time tasks      |
| Lambda              | ✅ Best       | Short & clean tasks |

---

