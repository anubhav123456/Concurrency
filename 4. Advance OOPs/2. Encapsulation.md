
---

# üìò **Notes: Encapsulation**
---

## ‚úÖ **Why hide things?**
- To make the interface simpler, we may want to hide unnecessary details.
- To protect the integrity of data on an object, we may hide or restrict access to some of the data and operations.
- To decouple the published interface from the internal details of the class, we may hide actual names and types of class members.
---

# ‚úÖ **1. Allowing direct access to data on an object can potentially bypass checks and additional processing your class has in place to manage the data.**

### ‚ùå Problem

If fields are **public**, other classes can modify them **without any checks**.
Your class loses control over its own data.

### ‚ùå Example (No Encapsulation)

```java
class BankAccount {
    public int balance;  // direct access - BAD
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        account.balance = -5000; // ‚ùå No validation: negative balance allowed!
        System.out.println(account.balance);
    }
}
```

### üî• What‚Äôs wrong here?

* The balance becomes **negative**, which should never be allowed.
* No validation, no checks, no business rules.
* Any external code can put the object in a **corrupted** or **invalid** state.

---

# ‚úÖ **2. Allowing direct access to fields means calling code would need to change when you edit any of the fields.**

### ‚ùå Problem

If you expose fields directly and later **rename**, **split**, or **change** those fields,
all external code that directly accesses them will break.

### ‚ùå Example (No Encapsulation)

```java
class Person {
    public String fullName;  // direct field
}

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        p.fullName = "Anubhav Gupta"; // works for now
    }
}
```

### üî• NOW imagine you change the class:

```java
class Person {
    public String firstName;
    public String lastName;
}
```

### ‚ùå What happens?

The previously working code:

```java
p.fullName = "Anubhav Gupta";
```

Will now fail.

Because external code depended on the **internal structure** of your class.

‚û°Ô∏è **This tight coupling makes your code fragile and hard to maintain.**

If you had used getters/setters, the internal fields could change without breaking code.

---

# ‚úÖ **3. Without Constructors, Object Can Be Created in an Invalid / Half-Baked State**

### ‚ùå Problem

If fields are public and you don't provide constructors,
the object might be created with **missing data** or **wrong data**.

### ‚ùå Example (No Encapsulation)

```java
class User {
    public String username;
    public String email;
}

public class Main {
    public static void main(String[] args) {
        User u = new User(); // ‚ùå No constructor
        // Forgot to set fields
        System.out.println(u.username); // null
        System.out.println(u.email);    // null
    }
}
```

### üî• What‚Äôs wrong?

* The object is **incomplete**.
* The programmer forgot to set required fields.
* You cannot enforce mandatory data.

### In real systems, this can cause:

* NullPointerExceptions
* Inconsistent objects
* Security issues (e.g., missing roles)

If the class had a constructor:

```java
User u = new User("anubhav", "test@example.com");
```

You guarantee that the object is **always valid** when created.

---

